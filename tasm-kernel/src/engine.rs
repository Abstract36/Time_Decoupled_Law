use crate::model::{Absence, Intent, IntentId, Slot};
use std::collections::HashMap;

/// Trait for the storage of Intents.
/// In a real system, this would be a database or ledger.
pub trait IntentRegistry {
    fn get_active(&self) -> Vec<Intent>;
    fn mark_absence(&mut self, intent_id: &IntentId);
    
    // Economic Logic
    fn get_balance(&self, account: &str) -> u64;
    fn slash_collateral(&mut self, account: &str, amount: u64);
}

/// In-Memory implementation for the POC.
pub struct MemoryRegistry {
    pub intents: HashMap<IntentId, Intent>,
    pub absences: Vec<Absence>,
    pub balances: HashMap<String, u64>, // Account -> Satoshis/Lamports
}

impl MemoryRegistry {
    pub fn new() -> Self {
        Self {
            intents: HashMap::new(),
            absences: Vec::new(),
            balances: HashMap::new(),
        }
    }

    pub fn add_intent(&mut self, intent: Intent) -> Result<(), String> {
        // Check collateral
        let balance = self.balances.get(&intent.creator).cloned().unwrap_or(0);
        if balance < intent.collateral {
            return Err("Insufficient funds for collateral".to_string());
        }
        self.intents.insert(intent.id.clone(), intent);
        Ok(())
    }

    pub fn set_balance(&mut self, account: &str, amount: u64) {
        self.balances.insert(account.to_string(), amount);
    }
}

impl IntentRegistry for MemoryRegistry {
    fn get_active(&self) -> Vec<Intent> {
        self.intents.values().cloned().collect()
    }

    fn mark_absence(&mut self, intent_id: &IntentId) {
        self.intents.remove(intent_id);
    }

    fn get_balance(&self, account: &str) -> u64 {
        self.balances.get(account).cloned().unwrap_or(0)
    }

    fn slash_collateral(&mut self, account: &str, amount: u64) {
        if let Some(bal) = self.balances.get_mut(account) {
            if *bal >= amount {
                *bal -= amount;
            } else {
                *bal = 0;
            }
        }
        // In a real system, this amount goes to a vault or is burned.
        // For now, it simply disappears from the user's pocket.
    }
}

/// The TASM Core Engine.
/// It advances time and crystallizes absences.
pub struct AbsenceEngine<R: IntentRegistry> {
    registry: R,
    current_slot: Slot,
}

impl<R: IntentRegistry> AbsenceEngine<R> {
    pub fn new(registry: R, start_slot: Slot) -> Self {
        Self {
            registry,
            current_slot: start_slot,
        }
    }

    /// Advance time to a new slot.
    /// Returns the list of NEW absences generated by this time step.
    pub fn advance_time(&mut self, new_slot: Slot) -> Vec<Absence> {
        if new_slot <= self.current_slot {
            return vec![];
        }

        self.current_slot = new_slot;
        let mut resolved_absences = Vec::new();
        
        // 1. Get all active intents
        let active = self.registry.get_active();

        // 2. Check for deadline violations
        for intent in active {
            if intent.deadline < self.current_slot {
                // Deadline passed! Absence is now a fact.
                let absence = Absence {
                    intent_id: intent.id.clone(),
                    declared_at: self.current_slot,
                };
                
                // 3. Update Registry (remove intent, potentially slash)
                
                // SLASHING LOGIC:
                // The absence is permanent, so the collateral is forfeit.
                self.registry.slash_collateral(&intent.creator, intent.collateral);
                
                self.registry.mark_absence(&intent.id);
                resolved_absences.push(absence);
            }
        }

        resolved_absences
    }
    
    pub fn get_registry_mut(&mut self) -> &mut R {
        &mut self.registry
    }
}
